
This directory is intended for PlatformIO Test Runner and project tests.

Unit Testing is a software testing method by which individual units of
source code, sets of one or more MCU program modules together with associated
control data, usage procedures, and operating procedures, are tested to
determine whether they are fit for use. Unit testing finds problems early
in the development cycle.

More information about PlatformIO Unit Testing:
- https://docs.platformio.org/en/latest/advanced/unit-testing/index.html



---------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------
#include <Keypad.h>

const byte ROWS = 4; 
const byte COLS = 4; 

char keys[ROWS][COLS] = {
  {'1', '2', '3', 'A'},
  {'4', '5', '6', 'B'},
  {'7', '8', '9', 'C'},
  {'*', '0', '#', 'D'}
};

// پایه‌های واقعی برای ESP32
byte rowPins[ROWS] = {14, 27, 26, 25};
byte colPins[COLS] = {33, 32, 23, 22};

Keypad keypad = Keypad(makeKeymap(keys), rowPins, colPins, ROWS, COLS);

void setup() {
  Serial.begin(115200);
  Serial.println("Ready. Press any key on the keypad...");
}

void loop() {
  char key = keypad.getKey();
  if (key) {
    Serial.print("Key pressed: ");
    Serial.println(key);
  }
}

---------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------



void Allarm(int blinkCountPerLoop , int blinkDelayMs, int loopCount, int loopPauseMs)
{
  for (int i = 0; i < loopCount; i++)
  {
    for (int j = 0; j < blinkCountPerLoop; j++)
    {
      digitalWrite(AllarmLedPin, HIGH);
      digitalWrite(AllarmBuzzerPin, HIGH);
      vTaskDelay(blinkDelayMs);
      digitalWrite(AllarmLedPin, LOW);
      digitalWrite(AllarmBuzzerPin, LOW);
      vTaskDelay(blinkDelayMs);
    }
    vTaskDelay(loopPauseMs); // وقفه بین حلقه‌ها
  }
}

void AlarmTask(void *param)
{
  int *args = (int *)param;
  int blinkCountPerLoop = args[0];
  int blinkDelayMs = args[1];
  int loopCount = args[2];
  int loopPauseMs = args[3];
  free(args);

  Allarm(blinkCountPerLoop, blinkDelayMs, loopCount, loopPauseMs);

  alarmTriggered = false;
  vTaskDelete(NULL);
}
-----------------------------------------------------------------
-----------------------------------------------------------------
-----------------------------------------------------------------
-----------------------------------------------------------------




void monitorInputSms()
{
  String response = "";
  unsigned long start = millis();
  while (millis() - start < 3000)
  {
    while (SIM808.available())
    {
      response += (char)SIM808.read();
    }
  }

  if (response.length() == 0 || response.indexOf("+CMT:") == -1)
    return;

  Serial.println("Raw Response from SIM808:");
  Serial.println(response);

  // استخراج شماره فرستنده
  String senderNumber = "";
  int quoteStart = response.indexOf("\"");
  int quoteEnd = response.indexOf("\"", quoteStart + 1);
  if (quoteStart != -1 && quoteEnd != -1)
  {
    senderNumber = response.substring(quoteStart + 1, quoteEnd);
  }

  // استخراج متن پیامک
  String smsText = "";
  int lastQuote = response.lastIndexOf("\"");
  if (lastQuote != -1 && lastQuote + 1 < response.length())
  {
    smsText = response.substring(lastQuote + 1);
  }

  // پاک‌سازی کاراکترهای خراب یا غیرقابل چاپ
  smsText.replace("\r", "");
  smsText.replace("\n", "");
  smsText.trim();
  for (int i = 0; i < smsText.length(); i++)
  {
    if (smsText[i] < 32 || smsText[i] > 126)
    {
      smsText[i] = ' ';
    }
  }

  Serial.println("------------ SMS Details ------------");
  Serial.print("Sender Number: ");
  Serial.println(senderNumber);
  Serial.print("Message Text: ");
  Serial.println(smsText);
  Serial.println("------------------------------------- send  SMS");

  if (senderNumber.length() > 3 && smsText.length() > 0)
  {
    enqueueSms(adminMobileNumber, ReportSmsTextGenerator(senderNumber, smsText), 0);
    compileSms(smsText, senderNumber);
  }
  else
  {
    Serial.println("⚠️ Failed to extract sender or message text.");
  }
}






